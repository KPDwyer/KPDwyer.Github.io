---
layout: post
title:  "RPGMaker Autotile Pipeline in Unity"
date:   2019-04-10 19:00:15 -0500
categories: Unity
---

* stuff
{:toc}



# Overview
# Goal
RPG Maker has a real nice "auto tile" system, whereby you load in a fairly simple asset and when you use the tile generated by that asset to draw on the Tilemap, it automatically renders each tile such that its aware of its local neighbors.

![Atlas on left, Editor Function on right]

This is generally known as AutoTiling, and will be referred to as such in this article.  

I set out to duplicate the functionality of RPGMaker's AutoTiling - specifically what is commonly known as their A2 sheet, shown above.  I was surprised to find that while Unity accommodates the creation of these AutoTiles, a few layers of complexity prevent it from being as smooth as RPGMaker's UX.  

My goal was to familiarize myself with the Tilemap pipeline by making it as low-effort as possible to convert an RPG Maker A2 tileset PNG into a Unity RuleTile.

# Obstacles

## Obstacle 1: 2D-Extras
Unity introduced its 2D Tilemap system some time ago, and it comes with very customizable tiles and brushes.  It's a great system, but it doesn't come with everything out of the box - you have to find their `2D-extras` repo on GitHub [link here] to really dig in to the common use cases for the flexibility it provides.  This is a pain, as it seems like most of the demos of this system I've seen have centered around the RuleTile, which isn't even in the core feature set. Odd.

## Obstacle 2: RuleTile's Interface
![Inspector Picture]
This is the obstacle I expected to find.  Based on previous reading, I knew that to use Unity's RuleTile meant to use their custom inspector.  While the inspector is very pretty, manually creating each rule takes an unreasonable amount of time - there are 256 possible combinations with 2 states in 8 directions.  That assumes we are using 2 states (we are!) but Unity throws a curveball by adding a "don't care" state on top! The total possible permutations rises to 6561.  We only care about 2 states, but even 256 permutations is too many:  RPGMaker's AutoTiler only actually cares about 48 of these permutations.  If you're interested in reading further about how AutoTiling works, check out these links: ![angry fish link] ![gamedevtutsplus link].  There is a lot of literature on the bit masking involved in AutoTiling, and this exercise pertains specifically to replicating RPGMaker's functionality in Unity.

Once those rules are set of course, we need to assign a sprite to each rule. That means having a folder of several sprites, and manually dragging them to the Sprite Field on the inspector.  This is a lot of friction between `finishing the art` and `being able to paint tiles with the art`, and it must be done for each unique tileset.  The crux of this exercise was, given a known tileset layout, remove all of the friction of turning a tileset into a RuleTile.

## Obstacle 3: RPGMaker's Filthy Lies
![A2 picture]
Keen readers may have already perceived 6 tiles total on the A2 sheet, yet the Autotile process calls for 48 unique tiles!  RPGMaker is doing something fishy here...  I used a sample tileset - what appears to be 6 32x32 tiles in a 2x3 grid (thus a resolution of 64 x 96).  Note below the highlighted Tile in the example screenshot.

![Atlas on left, Editor on right, highlight nefarious tile]

The highlighted tile doesn't actually exist in the base atlas! Now, I don't know the implementation details of how RPGMaker actually performs this, but my mental model suggests that while the UX + Source asset of RPGMaker suggest these tiles are 32x32, the tiling engine actually paints them as 16x16 tiles - each fullsized tile is actually 4 subtiles.  I refer to these with cardinal shorthand - NW,NE,SW,SE.  

![Single Tile broken up into quads]

This means the A2 tileset actually generates 48 usable fullsize tiles from a pool of 20 subtiles.  The top left fullsize tile is actually just a preview for RPGMaker's palette window, it remains unused in the actual tile painting+ rendering at runtime as it's 4 subtiles are contained within the bottom 4 tiles.

![A2 broken up into subtiles]

I knew early on I'd have to manually assign the quads to each rule, as there are too many layers to the translation to do it smoothly / mathematically.  I also discovered that the tiling edges matter: in the first tile set shown below, there is no discernible difference between Subtiles 9,10,5 & 6.  however if you simply cut the four of them out of the set and used them like that, it would be incorrect. 5&6 should be at the TOP of any tile they are involved in, while 9&10 should be at the bottom.  if we are listing them clockwise from the NW, [9,10,5,6] should actually be rendered as [6,5,10,9].  you can see why this matters if you take a look at the second image below.

![a2 carpet, a2 fence]

now that we know each subtile needs to appear in a target tile in the same local quadrant as its used in the tileset atlas, we can simplify the mapping to the following for the sake of manually assigning quads.

![Subtile map ref]

Now that we understand the functionality reasonably well, The most straightforward solution presents itself to us:  lets generate these 48 full-sized tiles from our pool of 20 subtiles.

# Implementation 1: Fullsized Tiles
## Target Output
The Ideal result of the fullsized tiles implementation is that a developer should be able to perform a single action (ideally a right-click menu item) on an A2 PNG and immediately be served a RuleTile generated from that asset.  Spoilers: I did it.  Double Spoilers: I hate it.

## Step by Step
The first step for any of these solutions is simply to generate the rules for the RuleTile.  this is sort of an inversion of the standard AutoTiling bitmask:  (looping through 0-255) Given this integer value, which tiles should be occupied for this rule?  We have some real ugly code for removing the rules we don't care about, but code elegance is just the small cost of reducing our total rule count by over 200 redundant rules.  this is the `GetRule(int neighbourMask)` function in `ImportAutotile.cs`.

We then need to generate a sprite for each rule, using a lookup table.  I've made my lookup tables ScriptableObjects for a few reasons - most importantly, a custom inspector ensures I can make the job of setting up the subtile indices as painless as possible.  Ultimately, the actual object is just an array of integers for subtile indices and a List of TilingRules for nicely visualizing what Rule + Quad each indices belongs too.  Users of this tool for an A2 tileset don't need to edit this ScriptableObject at all, but if you were to make a lookup table for a different style of tileset, it may be handy.

![screencap of scriptable object]  

So as we generate a sprite for each rule (see `GenerateSprite(int neighbourMask, int res, Texture2D source, AutoTileLookup lookup, string folderPath)` in `ImportAutotile.cs`), we grab the valus from our lookup table, convert them from Tile indices to Subtile indices based on their quadrant, then we generate a new texture2D, grab the pixels from the appropriate quads and use `SetPixels` to write the new texture. we save this texture with the mask value in the filename.

We do a quick save and refresh of our asset datatbase to be sure the files are imported correctly and have their metadata populated, then we simply iterate through the rules, loading the sprite we generated based on the tilemask for each rule.  Once we've assigned the sprites to the rules we save the RuleTile and voila! - a functioning RuleTile from our source atlas.

![gif funstionality]

## Problems
### Usage
First of all, you'll notice this operation is performed upon a PNG but also requires the lookup table data.  The nature of my role as someone who will have to make a few different lookup tables meant I didn't want to make this a simple `Right Click -> Generate Autotile` script, as I want to provide 2 pieces of information to the function: the actual PNG, and the lookup table.  Thus, I actually trigger the operation with a Sprite Field on the lookup table's scriptable object that triggers the function when you drag a sprite to it.  This is a minor detail though, and requires very little legwork to make it work with a right click.

![image of the scriptable object's inspector.]

### Texture Memory
This is the big con.  At best, this method results in a new 256x256 texture atlas full of all 48 fullsize tiles.  This is a lot larger than the 64x96 atlas we started with.  It also means we need to do something with this smaller source asset we used to generate all these tiles.  It irked me to delete this smaller source file once i had generated the behemoth atlas used to drive this RuleTile.

Surely, I thought, there must be a better way.  if this giant atlas came from these 32x32 generated from a smaller atlas' 16x16 tiles, couldn't we use the same source atlas to drive our AutoTile?

# Implementation 2: Subtiles
## Target Output
Rather than view the solution through the lens of the fullsized tiles that we perceive, what if we saw the solution through the lens of the smaller subtiles that we actually use in our implementation?  if we could somehow paint each subtile individually while conforming to the rules + position needs of the fullsized tiles, we'd have nearly the same functionality without generating a large atlas - in fact, we could use the source asset.  

Our goal for this implementation is to generate a brush at subtile scale - in this case thats a 16x16 tile - that gives us the same visual output as the initial implementation without generating any new textures.

## Step by Step
First of all, if we aren't generating new textures, we need to import the source texture properly. we do this in `ProcessSubtileTexture(Texture2D _texture, AutoTileLookup _lookup)` of `ImportAutotile.cs`.  we make sure to import the Texture2d as containing multiple sprites, then use our known measurement to slice the sprite in code based on the size of the Subtiles.  In this case I name them based on which Quadrant they are in and their Subtile ID.  After assigning the sliced metadata to the spritesheet of the Texture2D, I reimport the whole thing and use `LoadAllAssetsAtPath(path)` to make sure I load the individual Sprite assets at that path.

I sort them by name because the naming scheme used above means each subtile will be stored in it's own part of the list, from lowest Subtile ID to highest. I them generate the RuleTile and it's TilingRules exactly as was done previously.

Each Rule now needs 4 tiles, though: one for each Quadrant.  At this point I realized I hadn't thought this through at all.



# Failed Attempt: The Impossible Dream
# Closing

 -- old--
I finished off writing a basic animation generator, given a very specific folder layout:

![File Structure](/assets/animgenerator_files.jpg)

This layout (and most of the code in this this gist) is simply set up the way that it is because it fits my current process.  None of this is meant to be universal or overly generic, but it's a good starting point if you're looking for something similar.

The tool can generate animator controllers + clips, or just clips from a folder or selection.

![Menu Hierarchy](/assets/animgenerator_menu.jpg)

I left in fairly basic `Debug.Log()` messages tracking (useful to track what has been done, rather than actual progress).

![Log Output](/assets/animgenerator_output.jpg)

And it does it's best to organize the resulting Animator Controller - in my game the art is along 4 cardinal directions, so it places the output in columns of 4 States for the sake of organization.

![Controller Output](/assets/animgenerator_controller.jpg)

Obviously there's still a lot of work involved (timing individual frames, setting up transitions + parameters, etc), but this saves some time - especially if the default method of dragging batches of sprites onto a animation clip doesn't quite cover your bases.


<script src="https://gist.github.com/KPDwyer/1c4a490e5d4e8eef7bbe0272126a2f20.js"></script>
